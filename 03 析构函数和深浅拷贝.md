## 03 析构函数和深浅拷贝

## 1、构造和析构

```cpp
创建一个对象之后，让对象立刻拥有你希望它具有的值
如果不用构造函数初始化，需要为每个类提供一个public的init函数，再对象创建后立即调用init函数进行初始化
缺点：init只是一个普通函数，必须显示调用
     如果失误，对象没有初始化，那么结果将不确定，此外没有初始化的对象，内部成员变量的值是不缺定的。
```

```cpp
此时需要引入构造函数，与类同名的没有返回值函数，可以被重载；析构不可以被重载
eg:
	class Test {
		Test(int a, int b)
		Test(int a)
		~Test() 
	};
	
main: Test t1(1); // 创建t1对象并初始化
	  ~Test() 析构函数，不允许有返回值与形参，在一个函数生命周期结束后OS会自动回收其所分配的栈区内存，但不会回收堆区内存，析构函数的作用是用户在该区域内回收前面分配的内存，防止内存泄漏。
```

## 2、默认的无参构造和析构函数

```
在用户没有显示提供任何构造函数的情况下，函数中存在默认的无参构造函数，可以直接调用Test t1
在用户没有显示提供任何析构函数的情况下，函数中也会有一个默认析构函数
```

## 3、拷贝构造函数

```cpp
拷贝构造函数：用一个类对象来初始化另一个类对象
构造函数在创建新对象时使用
eg: Test t1; // 调用无参构造赋初值
	Test t2(t1) // 用t1对象来为t2对象赋初值，这里就是拷贝构造函数

拷贝构造函数：
// 用const将赋值变量保护起来
	Test(const Test & another) {
	x = another.x;
	...
	}
用户不显示的写拷贝构造函数，会调用默认的
Test t2 = t1;
Test t2(t1); // 这两个操作等价

Test t4;
t4 = t1; // 这里是调用t4的操作符函数 赋值，不是拷贝构造

```

## 4、类中默认函数的隐藏条件

```cpp
1、当类中没有任何显式的构造函数（显式的无参构造、显式的有参构造、显示的拷贝构造函数时），默认的无参构造函数就会出现。
2、当没有显式拷贝构造时，默认拷贝构造就会出现，有显式的有参构造也不会影响。
3、有默认的析构函数（OS会自动调，手动调用需要保证调用两次不会对函数产生奇怪影响），没有显式的析构函数时会出现
```

## 5、拷贝构造函数应用场景

```cpp
析构函数的调用顺序，与构造相反，（与出栈类似）
class Test
{
public:
    Test()
    {
        m_x = 0;
        m_y = 0;
    }
    Test(int x, int y)
    {
        m_x = x;
        m_y = y;
    }
    // 默认拷贝，直接赋值，不考虑指针、引用什么类型，会发生浅拷贝
    Test(const Test &another)
    {
        m_x = another.m_x;
        m_y = another.m_y;
        cout << "拷贝构造" << endl;
    }
    ~Test()
    {
        cout << "析构" << endl;
    }

private:
    int m_x, m_y;
};

void t1()
{
    Test t1(1, 2);
    Test t2 = t1;
    // 先析构t2，再析构t1
}

操作符函数
    
    // 操作符 赋值
    void operator=(const Test &another)
    {
        cout << "操作符" << endl;
        m_x = another.m_x;
        m_y = another.m_y;
    }
main
    Test t2;
    t2 = t1;
    

拷贝构造
void fun(Test t) // Test t = t1; 拷贝构造函数
{
    cout << "fun" << endl;
}

    Test t1(1, 2);
    fun(t1); // 执行的操作： Test t = t1; 此处调用了拷贝构造

```

### I 拷贝构造的其他应用场景（C11 的RVO优化，无需产生匿名对象）

```cpp
Test fun2()
{
    cout << "fun2" << endl;
    Test tmp(10, 20);
    // tmp.print();
    return tmp; //  Test xx = tmp 将tmp传给某匿名对象(拷贝构造)
}

void t2()
{
    cout << "t2" << endl;
    // Test x = fun2(); // 此处不会再触发拷贝，即将匿名对象改名字
    // x.print();
    fun2(); // 调用完成 匿名对象被析构
    cout << "t2 end" << endl;
}

黑马课上的执行结果是：
    t2
    fun2
    析构匿名对象
    析构tmp
    t2 end

system("pause") 会影响一般析构函数的调用

而在C11中，编译器对其进行了一个“RVO”（返回值优化），在RVO优化中，编译器可以避免创建一个临时变量（此处的匿名变量）来存放返回值，而是直接将返回值放在调用方分配的内存里，从而避免拷贝构造函数的调用，在这种情况下就不会产生匿名对象，也就不会有匿名对象被析构的情况发生。

    
Test fun2()
{
    cout << "fun2" << endl;
    Test tmp(10, 20);
    tmp.print();
    return tmp; //  Test xx = tmp 将tmp传给某匿名对象(拷贝构造)
}
return tmp 时会发生拷贝构造
    
void t2()
{
    cout << "t2" << endl;
    Test x;     // 无参构造
    // C++中一个变量只能初始化一次
    x = fun2(); // =操作符重载，tmp被析构
    x.print();
    // 最后x被析构
    cout << "t2 end" << endl;
}

```

### II 操作符重载

```cpp
    Test x;     // 无参构造
    x = fun2(); // =操作符运算，tmp被析构
    某些类中操作符特定的操作符行为，使该操作符可以作用在该类的对象上。操作符重载允许用户使用常见的数学和逻辑操作符，如加号、减号、等号等，用于自定义类型的对象上。例如，可以重载加号运算符，使得它能够将两个自定义类型的对象相加，就像对两个整数或浮点数进行相加一样。
    操作符重载语法：类名 + operator'要重载的操作符' (....) 
    eg:
    class MyClass {
	public:
    	MyClass operator+(const MyClass& rhs);
    	// ...
	};
在这个例子中，operator+ 函数将两个 MyClass 类型的对象相加，并返回一个新的 MyClass 对象。当使用加号运算符时，编译器会自动调用这个函数。例如：
    MyClass a, b, c;
	// ...
	c = a + b; // 编译器将自动调用 operator+ 函数
需要注意的是，操作符重载函数也可以重载为成员函数和非成员函数。成员函数的第一个参数是隐式的调用对象，非成员函数的第一个参数是显式的对象。此外，还应该遵循一些操作符重载的规则，比如避免改变操作符的基本语义，保持操作符的结合性和优先级等。
    
```



## 6、深、浅拷贝（为了防止内存泄漏，与重复释放同一块内存）

```cpp
深拷贝：可以拷贝 被拷贝处的一切内容，包括但不限于指针所指向的内容
浅拷贝：可以拷贝指针，但是不拷贝指针所指向的内容

// 深浅拷贝练习
class Teacher
{
public:
    Teacher(int id, char *name)
    {
        m_id = id;
        int len = strlen(name);
        m_name = (char *)malloc(len + 1);
        strcpy(m_name, name);
    }
    ~Teacher()
    {
        cout << "析构" << endl;
        if (m_name != nullptr)
        {
            free(m_name);
            m_name = nullptr;
        }
    }
    void print()
    {
        cout << m_id << ' ' << m_name << endl;
    }

private:
    int m_id;
    char *m_name; // 分配指针空间
    // char name[64]; // 分配栈上空间
};

void test()
{
    Teacher t1(1, "wh");
    t1.print();
    // 调用默认拷贝构造函数
    Teacher t2(t1);
    t2.print();
    // t2 指向的空间被释放，然后释放t1，free()出错
}

int main()
{
    test();
    system("pause");
    return 0;
}

//     Teacher t2(t1);调用默认拷贝构造函数只会将两个对象的name指向同一块内存，在t2执行完成后，t2调用析构函数，会将动态内存区释放，但t1仍会调用析构函数，此时free()出错
正确的代码，应该通过修改默认拷贝函数实现
    Teacher(const Teacher &another)
    {
        m_id = another.m_id;
        int len = strlen(another.m_name);
        char *m_name = (char *)malloc(len + 1);
        strcpy(m_name, another.m_name);
    }

```

**bug**：

```
为已经默认初始化的变量，再申请内存并指向它时，误在其名前写上数据类型，会引起非左值报错
```

**注意：构造函数中申请了堆区空间，在析构函数中一定要及时释放**

