# 07继承与派生

追求：高内聚，低耦合（原类依赖其他类越少越好）

## 1、类与类之间的关系

```cpp
class A{
	int a;
}

I B has A

class B{
	A a; // B中有A的对象
}

II B use A
class B{
void fun1(A &a);
void fun2(); // B中有函数需要使用A的对象
}

// 继承
III B is A
class B : public A{
	// B拥有A的全部成员变量、成员函数，且可以增加自己的内容
}
```

## 2、继承的基本定义

```
继承自父类的子类创建对象时，对象的空间与父类创建的对象内存空间不同。
```
**简单继承eg**

```cpp
class Stu
{
public:
    Stu(int id, string name)
    {
        this->id = id;
        this->name = name;
    }
    void print()
    {
        cout << this->id << ' ' << this->name << endl;
    }

private:
    int id;
    string name;
};

// 加入分数
class Stu1 : public Stu
{
public:
   								// 显式调用父类的构造函数
    Stu1(int id, string name, int score) : Stu(id, name)
    {
        this->score = score;
    }
    void print()
    {
        Stu::print();
        cout << this->score << endl;
    }

private:
    int score;
};
```

C++的可重用性通过继承来实现

## 3、继承(is A)相关的名词定义

```cpp

			A
		  /	  \
		B		C
	 /	\  \  /
	C1	C2 	C3
    
    父类/基类			子类/派生类
    B是A的派生类，又是C1、C2、C3的基类
    C1是B的子类（单继承）
    C3是B、C的派生类（多继承）
```

## 4、类的继承方式

**注意：**关键字`public`在类中表示访问控制权限，在被子类继承时表示`公有继承`

`protected继承：在当前类与子类中可以访问，类外不可以访问`

```cpp
规则：
	① 父类中的private 成员，不管哪种继承方式，子类均不可见
	② 如果是public继承，子类中的访问控制权限不变
	③ 如果是protected继承，子类中父类的public、protected成员均变成protected
	④ 如果是private继承，子类中父类的public、protected成员均变成private
	
可以得到如下表格
```

| 父类中的访问权限\继承方式 |  public   | protected | private |
| :-----------------------: | :-------: | :-------: | :-----: |
|          public           |  public   | protected |    \    |
|         protected         | protected | protected |    \    |
|          private          |  private  |  private  |    \    |

判断是哪种继承

```
先看：调用的成员变量（或成员函数）是在类外还是类中
再看：子类的继承方式
最后看：当前的子类中变量在父类中的访问控制权限
```

## 5、类的赋值兼容原则

**不可以用父类给子类赋值，因为父类空间 <= 子类空间；反之则成立**

```
① 子类对象可以直接当父类对象使用
② 子类对象可以给父类对象赋值
③ 子类对象也可以直接初始化父类对象
④ 父类指针可以直接指向子类对象 (多态)
⑤ 父类引用可以直接引用子类对象
```

**④举例：**

```cpp
class Parent:
	int a;
	
class Son: public Parent
	int b;
	父类所占内存			子类所占内存
		int a				int a
							int b
所以可以用子类给父类赋值
Parent *p;
Son *s;
Son ss;
Parent pp;
p = &ss; // 父类指针可以直接指向子类对象内存

好处:写一个传父类的接口，所以的子类都可以调用
void print(Parent & p / Parent * pp)
子引用、子类地址都可以直接传入，进行调用

```

## 6、子类中的构造和析构

```cpp
在子类构造前，一定会先调用父类的构造函数，其后子类先析构，父类再析构。
   
class P
{
public:
    P(int a)
    {
        cout << "P(int)" << endl;
        this->a = a;
    }
    ~P()
    {
        cout << "~P()" << endl;
    }

private:
    int a;
};

class S : public P
{
public:
    S(int a, int b) : P(a)
    {
        cout << "S(int, int)" << endl;
        this->b = b;
    }
    ~S()
    {
        cout << "~S()" << endl;
    }

private:
    int b;
};
    
    
P(int)
S(int, int)
~S()
~P()
```

## 7、子类与父类中出现重名变量

```cpp
用域名去访问，此外再传参时注意区分一下即可，在子类中的this也是指向子类对象的指针
class S : public P
{
public:
    S(int p_a, int s_a) : P(p_a)
    {
        this->a = s_a;
    }
    ~S()
    {
        cout << "~S()" << endl;
    }
    void print()
    {
        cout << P::a << ' ' << this->a << endl;
    }

private:
    int a;
    int b;
};
```

## 8、继承中的static

```cpp
父类中public的静态成员变量，仍为整个家族类公有。
```

