# 8、多继承、虚继承、多态、虚析构

## 1、多继承与虚继承

```cpp
多继承
				
	    class Furniture (int m)
              /                 \  
         class Bed (m)      class Sofa (m)
               \                /
      	class BedSofa (Bed::m、Sofa::m) 多继承
    	Bedsofa sb; sb.m 不知道找哪个m，应该指定具体的类中的m
	为了防止孙类在继承其父类时，将其祖类中的变量拷贝多份，进而出现指代不明的现象，在其父类继承祖类的时候，需在继承方式前+关键字“virtual” 
        eg class Bed : virtual public Furniture
        当孙类发现，父类中是虚继承祖类时，同一变量只会直接从祖类中拷贝一份，不会再多继承多份。
 
                            
虚继承
              class Furniture (int m)
              /                 \  
       virtual class Bed (m)    virtual class Sofa (m)
               \                /
      	    class BedSofa (Bed.m) 直接继承自祖类
                若父类有非继承于祖类的成员，也会被孙类继承
```



## 2、多态的定义和多态的三个必要条件

```cpp
C++多态(polymorphism)指的是：由继承产生的相关的不同的类，其对象对同一消息会作出不同的相应。

class A
{
public:
    A(string kongfu)
    {
        this->kongfu = kongfu;
    }
    virtual void show()
    {
        cout << "A " << kongfu << endl;
    }
    string name;
    string kongfu;
};

class B : public A
{
public:
    B(string name) : A(name)
    {
    }
    virtual void show()
    {
        cout << "B " << this->kongfu << endl;
    }
};

// 可以用父类指针指向子类对象
void print(A *a)
{
    cout << a->name << "  " << a->kongfu << endl;
}
实现多态需要有三个条件：
    ① 要有继承
    ② 要有虚函数重写（最好在子类中也加上这个关键字，虽没有意义，但可以加强可读性） （现在编译器已经优化完，会根据传入基类的类型来调用相应类中的函数）
    ③ 要有父类指针或引用 指向 子类对象
```

**多态的意义：之前的架构，可以被未来继续拓展**

## 3、多态的意义

```cpp
class Wxy
{

public:
    virtual int score()
    {
        return 100;
    }
};

class Wh : public Wxy
{
public:
    virtual int score() // 将需要使用多态的函数前+virtual
    {
        return 99;
    }
};

// 继承Wh类，将score进行虚函数重写
class Wh1 : public Wh
{
public:
    virtual int score()
    {
        return 101;
    }
};

void comapre(Wxy &wxy, Wh &wh)
{
    if (wxy.score() > wh.score())
        cout << "wxy win" << endl;
    else
        cout << "wh win" << endl;
}

Main:
    Wh wh;
    Wxy wxy;
    Wh1 wh1;
    comapre(wxy, wh1);
    comapre(wxy, wh);

Res:
	wh win
	wxy win
```

## 4、动态联编和静态联编

```
1、联编是：程序模块、代码之间互相关联的过程
2、静态联编：指程序的匹配、连接在编译阶段完成，也称为：早期匹配。重载函数使用静态联编。
3、动态联编：动态联编是指程序联编推迟到运行时进行，所以又叫晚期联编（迟绑定），switch语句、if语句、多态（虚函数重写）都是动态联编
```

```
1、C++与C都属于静态编译型语言
2、在编译时，编译器自动根据指针的类型判断指向的是一个什么样的对象，所以编译器会认为父类指针指的是父类对象
3、由于程序没有运行，所以不可能知道父类指针指的是父类还是子类对象，出于安全的考虑，编译器会假定父类指针只指向父类对象，这种特性就是静态联编
4、多态的发生是动态联编，是在程序执行的时候去判断父类指针应该调用的方法
```

## 5、虚析构函数

```cpp
class A;
class B : public A; 
A a;	B b;
在B的构造函数发生作用前，默认先调A的构造函数

创建类成员指针时，不可悬空指针（不可如eg：A *a;）

class A
{
public:
    A()
    {
        cout << "A()" << endl;
        this->p = new char[64];
        memset(this->p, 0, 64);
        strcpy(this->p, "A()");
    }
    virtual void print()
    {
        cout << "A" << endl;
    }
    ~A()
    {
        cout << "~A()" << endl;
        if (this->p != nullptr)
        {
            delete this->p;
            this->p = nullptr;
        }
    }

private:
    char *p;
};

class B : public A
{
public:
    B()
    {
        cout << "B()" << endl;
        this->p = new char[64];
        memset(this->p, 0, 64);
        strcpy(this->p, "B()");
    }
    virtual void print()
    {
        cout << "B" << endl;
    }
    ~B()
    {
        cout << "~B()" << endl;
        if (this->p != nullptr)
        {
            delete this->p;
            this->p = nullptr;
        }
    }

private:
    char *p;
};

void fun(A &a)
{
    a.print();
}

void t(A *p) // 要用到多态的是print函数，所以要在基类中 + 上virtual
{
    p->print();
    delete p;
}

B *b = new B;
test(b);
执行结果，如下
            A()
            B()
            B
            ~A()
只会除非A的析构，会造成内存泄漏，因为在一开始触发B的构造函数的时候，会先触发其基类的构造函数，在堆上开辟了一块子类无法访问的空间，最后析构时，只将其释放，未将后面B所用空间释放，造成了内存泄漏。

	a（栈）		    堆
	*p  ---------->   char[64]
	
	 b  
	*p  ---------->   char[64] // A中构造函数的
					  char[64]  B构造函数产生的，也需要析构
    
    所以需要将父类的析构函数前也加上关键字"virtual“
    因为析构的顺序与构造相反，触发了B析构，之后一定会触发A析构
    触发B构造，在此之前一定会触发A构造
```

## 6、重载、重写、重定义

```
重载：一定在一个作用域内，函数的形参列表不同
重定义：
    发生在两个不同的类中，（不加virtual的普通函数）一个是父类，一个是子类
    重写： 父类是虚函数，子类与其一模一样，发生多态
```

## 7、多态的原理

```cpp
class Parent{
    virtual int show() {}
	int c;
};

class Child : public Parent{
    virtual int show() {}
};

在一个父类中，用virtual 声明一个虚函数，不管这个类是否能被继承，都会为其开辟一张虚函数表（存放在常量区），有几个虚函数会加几项。
若该父类被子类继承，那么会为子类也开辟一张虚函数表。
若一个类有“virtual”虚函数关键字，在编译器给该对象开辟空间的时候，会默认增加一个指针”vptr“（用sizeof统计时会占类中大小），该指针始终指向该类的虚函数表。
开辟空间时eg:					   >   Child::虚函数表 
	Child(10)   ->		vptr	/	  virtual int Child::show()
        		     	 10
        Parent 同上
Child c;
Parent *p = &c;    
p会指向子类的虚函数表的vptr，然后通过偏移去找子类中有无满足调用条件的方法，若无的话则去父类中查找，若还是无，则报错。
```

### 7.1 虚函数表和`vptr`指针

```
① 当类中声明虚函数时，编译器会在类中生成一个虚函数表
② 虚函数表是一个存储类成员函数指针的数据结构
③ 虚函数表是由编译器自动生成与维护的
④ virtual成员函数会被编译器放入虚函数表中
⑤ 存在虚函数时，每个对象中都有一个指向虚函数表的指针（vptr指针）
```

如果调用一个普通函数，编译器不会去查虚函数表（eg，父类中的函数未声明为虚函数，仅在子类中声明）

*<font color="red">注意：</font>*

1、通过虚函数表指针`vptr`调用重写函数是在程序运行时进行的，因此需要通过寻址操作才能确定真正应该调用的函数（动态联编），而普通成员函数是编译时就确定了调用的函数，因而在效率上，<font color = "red">虚函数的效率要低很多。</font>

2、出于效率考虑，没有必要将所有成员函数都声明为虚函数。

3、C++编译器，执行run函数，不需要区分是子类对象还是父类对象，而是直接通过p的`vptr`指针所指向的对象函数执行即可。

### 7.2 验证`vptr`指针的存在

```cpp
class A{
    pub: void A() {}
    pvt: int a;
};

class B{
  	pub: void B() {}
    pvt: int b;
};
求sizeof：4	4

class C{
  	pub: virtual C() {};
    pvt: int a;
};
求sizeof：8

class D{
  	pub: virtual D() {};
    	 virtual X() {};
    pvt: int a;
};
求sizeof：8 只需要一个虚函数指针，其余只需要往里面填数据即可，此外，求size时需要对齐
```

### **7.3  `vptr`指针分布初始化**

```
注意：构造函数中最好不要写业务，有时会有意料之外的事情发生，写成员的初始化即可。
```

**探究1**

```cpp

class A
{
public:
    A(int a)
    {
        cout << "A()" << endl;
        this->a = a;
        print();
    }
    virtual void print()
    {
        cout << " A " << endl;
    }

private:
    int a;
};

class B : public A
{
public:
    B(int a, int b) : A(a)
    {
        cout << "B()" << endl;
        this->b = b;
    }
    virtual void print()
    {
        cout << "B " << endl;
    }

private:
    int b;
};

void test()
{
    A *p = new B(1, 2);
    delete p;
}

输出：
	A()
	A
	B()
```

在B的构造函数触发前，会先触发A的构造函数，这时候会在子对象中先创建[`vptr`、a]的空间（当成父类对象解析），然后此时的`vptr`指向父类的虚函数表，会继续执行A构造函数中的函数，在父类对象构造完成后，会将对象当成解析，后续`vptr`指针会指向子类的虚函数表。

**结论：`vptr`指针是分布初始化的，在构造函数中不要写业务**

### 7.4 父类指针和子类指针的步长

指针`++`，并不是`+1`，而是跨步相加

```cpp
class A
{
public:
    A(int a)
    {
        this->a = a;
    }
    virtual void print()
    {
        cout << a << endl;
    }

    int a;
};

class B : public A
{
public:
    B(int a) : A(a)
    {
    }
    virtual void print()
    {
        cout << a << endl;
    }

    int a;
    int b;
};

void test()
{
#if 0
    A *p = new B(1, 2);
    // p->print();
    delete p;
#endif

    B arr[] = {B(0), B(1), B(2)};
    A *p = &arr[0];
    for (int i = 0; i < 3; i++)
    {
        p->print();
        p++;
    }
}
```

`A *p = &arr[0];`

`p ++ `每次等于 `p += sizeof(A),` 父类指针偏移之后会出错。

`B *p = &arr[0];`

`p ++ `每次等于 `p += sizeof(B)`

### 7.5 纯虚函数和抽象类

**如果一个类有纯虚函数，不管他有没有成员变量，那么就称这个类是抽象类**

**一个普通类想继承抽象类，必须要重写纯虚函数**

同一个接口，利用多态可以实现不同业务

抽象类可以将main函数跟具体实现做一个隔离（解耦合）

```cpp
virtual double getArea() = 0;

class Shape
{
public:
    // 纯虚函数，该类中无论是否有成员变量，该类都为抽象类
    virtual double getArea() = 0;
    int a;
};

class Circle : public Shape
{
public:
    Circle(int a)
    {
        this->a = a;
    }
    virtual double getArea()
    {
        cout << "圆" << endl;
        return 2 * 3.14 * a;
    }
    int a;
};

class Square : public Shape
{
public:
    Square(int a)
    {
        this->a = a;
    }
    virtual double getArea()
    {
        cout << "正方形" << endl;
        return a * a;
    }
    int a;
};

void print(Shape * sp) {
    cout << sp->getarea() << endl;
}

void test()
{
    Shape *sp1 = new Circle(1);
    cout << sp1->getArea() << endl;
    Shape *sp2 = new Square(1);
    cout << sp2->getArea() << endl;
}
依赖倒转模式
```

后续若要增加一个求三角形面积，可以不用修改现有代码，做到了main与具体业务的隔离，解耦合。

此处的main只与Shape相关，若不使用多态，main会与每个类相关，耦合度高，不好，应修改为面向抽象类编程。

**此外，注意：纯虚函数的类不能用来实例化对象，若想实例化，必须要重新该父类中的所有的纯虚函数**

### 7.6 纯虚函数与多继承

```cpp
class implt1 {
pub:
	virtual void fun1() = 0;
	virtual void fun3() = 0;
};

class implt2{
	virtual void fun2() = 0; 
};

class Child : public impl1, public impl2 {
    virtual void fun1() {}
    virtual void fun2() {} 
	virtual void fun3() {}
};

main:
	implt1 *p1 = new Child;
	p1只可以使用implt1中的方法，不可以调用implt2中的方法，反之亦然。对p1而言。implt2中的内容不可见。
```

### 7.7 面向抽象类编程-例子

一个类中最好只有一个纯虚函数，便于拓展。

如果一个类中有多个纯虚函数，那么在继承拓展时，需要同时维护三个函数

**注意：纯虚函数只需要有声明，不需要有定义（构造函数）**

## 8、函数指针

### 8.1函数指针的语法和意义

```cpp
int func (int a, int b) {
	cout << "func" << endl;
}

// 推荐函数指针写法 1
typedef int(FUNC) (int, int);
FUNC *fp = nullptr;
fp = func;
fp(1, 2); // 等价于 (*fp)(1, 2);

// 推荐函数指针写法 2
int(*fp1)(int, int) = nullptr;
fp1 = func;
fp1(1, 2);
```

用函数指针实现多态（架构函数）
