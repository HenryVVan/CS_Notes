# 8、多继承、虚继承、多态、虚析构

## 1、多继承与虚继承

```cpp
多继承
				class Furniture (int m)
              /                 \  
         class Bed (m)      class Sofa (m)
               \                /
      			  class BedSofa (Bed::m、Sofa::m) 多继承
    					Bedsofa sb; sb.m 不知道找哪个m，应该指定具体的类中的m
		为了防止孙类在继承其父类时，将其祖类中的变量拷贝多份，进而出现指代不明的现象，在其父类继承祖类的时候，需在继承方式前+关键字“virtual” 
        eg class Bed : virtual public Furniture
        当孙类发现，父类中是虚继承祖类时，同一变量只会直接从祖类中拷贝一份，不会再多继承多份。
 
                            
虚继承
              class Furniture (int m)
              /                 \  
       virtual class Bed (m)    virtual class Sofa (m)
               \                /
      	    class BedSofa (Bed.m) 直接继承自祖类
                若父类有非继承于祖类的成员，也会被孙类继承
```



## 2、多态的定义和多态的三个必要条件

```cpp
C++多态(polymorphism)指的是：由继承产生的相关的不同的类，其对象对同一消息会作出不同的相应。

class A
{
public:
    A(string kongfu)
    {
        this->kongfu = kongfu;
    }
    virtual void show()
    {
        cout << "A " << kongfu << endl;
    }
    string name;
    string kongfu;
};

class B : public A
{
public:
    B(string name) : A(name)
    {
    }
    virtual void show()
    {
        cout << "B " << this->kongfu << endl;
    }
};

// 可以用父类指针指向子类对象
void print(A *a)
{
    cout << a->name << "  " << a->kongfu << endl;
}
实现多态需要有三个条件：
    ① 要有继承
    ② 要有虚函数重写（最好在子类中也加上这个关键字，虽没有意义，但可以加强可读性） （现在编译器已经优化完，会根据传入基类的类型来调用相应类中的函数）
    ③ 要有父类指针或引用 指向 子类对象
```

**多态的意义：之前的架构，可以被未来继续拓展**

## 3、多态的意义

```cpp
class Wxy
{

public:
    virtual int score()
    {
        return 100;
    }
};

class Wh : public Wxy
{
public:
    virtual int score() // 将需要使用多态的函数前+virtual
    {
        return 99;
    }
};

// 继承Wh类，将score进行虚函数重写
class Wh1 : public Wh
{
public:
    virtual int score()
    {
        return 101;
    }
};

void comapre(Wxy &wxy, Wh &wh)
{
    if (wxy.score() > wh.score())
        cout << "wxy win" << endl;
    else
        cout << "wh win" << endl;
}

Main:
    Wh wh;
    Wxy wxy;
    Wh1 wh1;
    comapre(wxy, wh1);
    comapre(wxy, wh);

Res:
	wh win
	wxy win
```

## 4、动态联编和静态联编

```
1、联编是：程序模块、代码之间互相关联的过程
2、静态联编：指程序的匹配、连接在编译阶段完成，也称为：早期匹配。重载函数使用静态联编。
3、动态联编：动态联编是指程序联编推迟到运行时进行，所以又叫晚期联编（迟绑定），switch语句、if语句、多态（虚函数重写）都是动态联编
```

```
1、C++与C都属于静态编译型语言
2、在编译时，编译器自动根据指针的类型判断指向的是一个什么样的对象，所以编译器会认为父类指针指的是父类对象
3、由于程序没有运行，所以不可能知道父类指针指的是父类还是子类对象，出于安全的考虑，编译器会假定父类指针只指向父类对象，这种特性就是静态联编
4、多态的发生是动态联编，是在程序执行的时候去判断父类指针应该调用的方法
```

## 5、虚析构函数

```cpp
class A;
class B : public A; 
A a;	B b;
在B的构造函数发生作用前，默认先调A的构造函数

创建类成员指针时，不可悬空指针（不可如eg：A *a;）

class A
{
public:
    A()
    {
        cout << "A()" << endl;
        this->p = new char[64];
        memset(this->p, 0, 64);
        strcpy(this->p, "A()");
    }
    virtual void print()
    {
        cout << "A" << endl;
    }
    ~A()
    {
        cout << "~A()" << endl;
        if (this->p != nullptr)
        {
            delete this->p;
            this->p = nullptr;
        }
    }

private:
    char *p;
};

class B : public A
{
public:
    B()
    {
        cout << "B()" << endl;
        this->p = new char[64];
        memset(this->p, 0, 64);
        strcpy(this->p, "B()");
    }
    virtual void print()
    {
        cout << "B" << endl;
    }
    ~B()
    {
        cout << "~B()" << endl;
        if (this->p != nullptr)
        {
            delete this->p;
            this->p = nullptr;
        }
    }

private:
    char *p;
};

void fun(A &a)
{
    a.print();
}

void t(A *p) // 要用到多态的是print函数，所以要在基类中 + 上virtual
{
    p->print();
    delete p;
}

B *b = new B;
test(b);
执行结果，如下
            A()
            B()
            B
            ~A()
只会除非A的析构，会造成内存泄漏，因为在一开始触发B的构造函数的时候，会先触发其基类的构造函数，在堆上开辟了一块子类无法访问的空间，最后析构时，只将其释放，未将后面B所用空间释放，造成了内存泄漏。

	a（栈）		    堆
	*p  ---------->   char[64]
	
	 b  
	*p  ---------->   char[64] // A中构造函数的
					  char[64]  B构造函数产生的，也需要析构
    
    所以需要将父类的析构函数前也加上关键字"virtual“
    因为析构的顺序与构造相反，触发了B析构，之后一定会触发A析构
    触发B构造，在此之前一定会触发A构造
```

## 6、重载、重写、重定义

```
重载：一定在一个作用域内，函数的形参列表不同
重定义：
    发生在两个不同的类中，（不加virtual的普通函数）一个是父类，一个是子类
    重写： 父类是虚函数，子类与其一模一样，发生多态
```

