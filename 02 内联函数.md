## 1、内联函数

```cpp
inline 函数与宏函数类似，不需要压栈出栈
宏函数的缺点：不会对传递形参进行检测，对累加类型(a++..)直接替换，可能与预期值不符 
优点：预处理期展开，无压栈过程    
#define MAX(a, b) \
    ((a) > (b) ? (a) : (b))
    
省去函数调用时：出入栈、跳转、返回的开销

// inline 传a++时会先传入再++，与预期保持一致
inline void print() {
	cout << a > b ? a : b << endl;
}

定义为inline后 由编译器直接展开，省去压栈出栈
inline 适合 代码比较少的来节省开销
① 不能存在任何的循环语句
② 不能存在过多的判断
③ 函数体不能太大
④ 不能对函数进行取地址操作
⑤ 内联声明必须在函数调用之前

代价： 由于内联函数的函数体在代码段中会出现多个“副本”，因此会增加代码段空间。
本质上是牺牲代码段空间换程序运行效率，故只适合将函数体很小但被频繁调用的函数声明为inline类型
```

## 2、函数默认参数和占位参数

```cpp
C++中默认参数必须是从右往左赋值的

int getValue(int len, int wid, int hei = 1)
该函数中高度默认值为1，如果用户为其传参则使用用户传入值，若用户不传则使用默认值

占位参数：（是设计时的一个“坑”）
void fun(int a, int) // 操作重载时的亚元 函数原型 void fun(int, int)
第二个int是占位符，传参时需要传两个int型，但无法对第二个int进行操作
可以把占位参数跟默认参数写在一起，eg
void fun(int a, int = 0)
调用时可用 fun(10, 100),也可以直接fun(10)
```

## 3、函数重载（需要在 一个作用域下）

```
函数类型：函数的返回值、函数形参列表（参数个数、参数类型、参数顺序）
函数重载：
	① 函数同名，但形参列表不同
	② 返回值不是构成函数重载的条件
	③ 使用函数重载，尽量不要再使用默认参数，避免出现函数（歧义）冲突

```

![image-20230319094802884](C:/Users/henry/AppData/Roaming/Typora/typora-user-images/image-20230319094802884.png)

```cpp
仅使用占位符也能构成重载

void f(int a) 
void f(double b)

f(1.3f) -> 隐式转换成double 再调f
如果能够严格匹配调用的，重载调用
如果没有完全匹配的，调用隐式转换 f('a')：字符串会隐私转换成int
如果匹配不到，返回调用失败

// 重定义，函数返回值类型并不是重载的必要条件
void f(int a)
char f(int a)

重载的底层实现： name mangling(倾轧), 对函数名改名，进而区分参数不同的同名函数
实现原理：用v c i f l d表示void char int float long double及其引用
eg：
   	void f(char a)				// f_c(char a)
    void f(char a, int b)		// f_ci(char a, int b)
    
默认参数会不算函数重载，占位符算
   	int f(int a, int) 算
    int f(int a) 算
    int f(int a, int = 0) 不算重载

void f(int a, int b) 和 int f(int a, int b, int c) 是函数重载吗？
是，编译器看到的是f_ii f_iii，构成重载    
```

## 4、函数重载与函数指针

```cpp

// 1、定义一种函数类型
typedef int(MY_FUN) (int, int)

int f(int a, int b) {
	cout << a << ' ' << b << endl;
	return 0;
}

main():
	MY_FUN *fp = nullptr;
	fp = f;
	fp(1, 2);

// 2、定义一种指向该函数的指针类型
typedef int(* MY_FUN_P) (int, int) 
    
f():同上
main()：
    MY_FUN_P fp1 = nullptr;
	fp1 = f;
// 函数指针使用时无需加*
	fp1(2, 3);

常用方法
// 3、通过原有函数类型直接定义函数指针，无需typedef
	int(* fp2) (int, int) = nullptr;
	fp2 = f; // f_ii，此处会发生函数重载
	fp2(3, 4);

定义的函数指针有几个参数，就只能重载匹配几个参数的
int f(int a, int b, int c) 
int f(int a, int b)    

    
int(*fp3) (int, int, int) //只能重载第一个f
int(*fp2) (int, int) //只能重载第二个f

fp2 = f; // 此处会发生函数重载匹配，在调用函数指针时，所调用的函数已经固定了
fp2(1, 2, 3) //报错，该函数指针无法接收三个参数
注：函数重载会有隐式转换，但调用具体函数执行时，类型不匹配会报错
```

## 5、类和对象

```cpp
// 类
class Advhero {
    public: // 访问控制权限
    	char name[64];
    	int sex;
}

main: 
	定义对象
	Advhero ahero;

类与结构体的区别：
    对结构体操作的函数必须写在全局中
    对类操作的函数可以写在类里，可以无需传参

访问控制权限：
    public：在类的内部（{}作用范围为类的内部）、外部（eg：主函数中...）均可访问
    private：仅能在类的内部 {}作用范围内访问
    
class Animal
{
public:
    char kind[64];
    void run()
    {
        cout << kind << " run" << endl;
    }

private:
    void eat()
    {
        cout << kind << " eat" << endl;
    }
};

在main中，只可以调用：dog.run()，不可以调用eat()
```

## 6、类的封装

```cpp
一般类的成员放在private中
protected：保护控制权限，在单个类中与private一样，在类的继承时与private有区别

将类的属性变量返回，使用getter、setter方法
public:
	int get_year() {
        return year;
    }
	void set_year(int a) {
        year = a;
    }
private:
	int year;

class 不给具体访问权限时，默认为private
 
```

## 7、面向过程和面向对象

```cpp
void eat(class Dog & d, char *food) {
}

class Dog {
public: 
	char name[64];
	char food[64];
private:
	cout << name << "eat" << food << endl;
};

main:
// 面向过程
 	eat(dog, ”肉“)
	Dog dog;
	
// 面向对象
	dog.eat();
```

## 8、计算圆的周长和面积

```cpp
// 正确写法
class Circle
{
public:
    double get_circle_girth()
    {
        return 2 * 3.14 * radius;
    }
    double get_circle_area()
    {
        return 3.14 * radius * radius;
    }
    void set_radius(int r)
    {
        radius = r;
    }

private:
    int radius;
};

// 经典错误写法
class Circle {
public:
	void set_r(int x) {
		r = x;
	}
	double get_a() {
		return area;
	}
    double get_g() {
        return girth;
    }
    
private:
	double r;
	double area = 3.14 * r * r;
	double girth = 2 * 3.14 * r;
};
```

![image-20230320110702741](C:/Users/henry/AppData/Roaming/Typora/typora-user-images/image-20230320110702741.png)

因为类的成员属性需要在内存中分配空间，而成员方法不需要分配空间

把计算area、girth的写到private中在初始化分配内存时会给随机值，后续没有对area、girth的计算，所以出现随机值。

## 9、类的多文件编写

```cpp
.h文件
// 防止这个头文件被重复引用
#pragma once 
写函数声明
// .cpp
写函数实现
    注意写类的实现时，一定需要在函数名前加上xx::
double CircleA::get_x() {
    return x;
}
// Cuce类判断方法
	bool equal(Cube &another)
    {
        if ((x == another.get_x() && (y = another.get_y()) && (another.get_z())))
            return true;
        else
            return false;
    }

// 多文件

```

