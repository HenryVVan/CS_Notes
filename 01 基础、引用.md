## 1、C++基础

```cpp
namespace 
// 定义命名空间
namespace space_A {
	int a = 10;
}

{

} '{}'包围的范围是其作用域

namespace可以嵌套，此外直接using 一个namespace时要注意不会引起歧义

嵌套命名空间时，对其他命名空间的引用要放在整体命名空间的最下面

// 命名空间代码
namespace space_a
{
    namespace space_b
    {
        struct teacher
        {
            int id;
            char name[64];
        };
    } // namespace space_b
    using namespace space_b;
}

// 主函数代码
    using namespace space_a;
    teacher t;
    t.id = 10;
```

## 2、C++对C的增强和bool

```cpp
1、C语言要先定义再使用
C++中的变量可以随用随定义

2、C++对全部变量检测能力增强
全局区
	int g; // bss段分配
	int g = 20; // data段分配
	// C能通过、c++有重定义警告
在C语言里会认为：先定义，再赋值
3、struct结构体增强，在C语言定义结构体变量，需要用struct/typedef
	C++中不需要加struct关键字（C++中当类处理）
4、函数增强
C语言中：未指明返回类型也能通过
	f() {
		return 1;
	}
	f(int a) {
	
	}
	f(1, 2, 3) 也能通过
C++做了检测，便于程序员判断
	C++ f(1, 2) 会有waring，不支持多传形参
5、增加bool类型
C语言中：0假、其他真
C++中：增加了bool类型 true 1 / false 0，也兼容C

```

## 3、C++对三目运算符的增强

```
1、三目运算符(?)增强
C中, （a > b) ? a : b 是一个右值
C++中，三目运算符返回是一个左值（or 引用），可以赋值
```

## 4、const增强

```cpp
const int a (常量仍然需要初始化)
int const a 
// 这两个等价， 都是常整型数

const int * c
// const 修饰其右最近内容，此处只c所指向的int内容不能被修改

int const * d
// 此处表示指针d的指向不能被修改，d所指向的空间内容可以被修改

const int * const e
// 此处表示指针d与其所指向的内存都不可被修改


符号表在只读区的text段（地址对程序员不可知），所以C++中的const int变量是真正的常量，而在C中仍是一个可以通过指针去修改的变量，它会在栈中开辟空间。
const int型变量，C++编译器自动将其对应到符号表中的
key -> value
a	 	10
该操作与在预处理（展开）阶段的宏定义有点类似
编译器将常变量直接视为常量
const int a = 1;
int *p = (int *)&a;
p指向的是编译器临时分配的一个存放a的值的空间，该空间与a无关。

```

## 5、枚举增强

```cpp
C中
// 无需赋值也是自动赋0 1 2 3...
enum season {
	SPR = 0,
	SUM = 1,
	AUT = 2
}
// 可以把int类型赋给枚举类型，但在实际使用中不知道对应哪个
enum season a = 2;

C++中
enum season a = SPR (不可将枚举类型改成int型)
```

## 6、C++对C的拓展：引用类型

**①引用没有定义，是一种关系型声明，声明它与原来的某一变量（实体）的关系，所以其类型应与原类型保持一致，且不分配内存，与被引用的变量具有相同地址，在常量区有空间，对程序员不可见，不在栈上开辟空间**

**②引用必须要初始化，一经声明，不可改变**

**③可对引用进行再次引用，多次引用的作用效果是：某一变量具有多个别名**

**④& 符号前有数据类型时，是引用，其余情况是取地址**

```cpp
C中可以用typedef 可以对 类型改名，但无法对变量使用
引用
int a = 1；
// b是对a的引用
int &b = a;
修改b，a也会随之修改

C中改变形参数值
void change(int *p) {
	*p = 1;
}
C++中省去对指针的操作
void change(int &p) {
	p = 1;
}
------------------------------------------
// 结构体
struct stu {
	int id;
	char name[64];
};

// 值拷贝
void print0(stu a) stu a = s, 值拷贝，慢
{
    cout << a.id << ' ' << a.name << endl;
}

// 指针
void print2(stu *a) 传地址 stu *a = &s;
{
    cout << a->id << ' ' << a->name << endl;
}

// 引用
void print1(stu &a) 传引用 stu &a = s; 高效
{
    cout << a.id << ' ' << a.name << endl;
}

int f(int u) // u 在函数调用传参时，一定会被初始化
```

## 7、引用的本质

```
引用所占的大小，与指针是相等的
常量需要初始化，引用也要初始化，引用可能是一个常量
所以引用本质上是一个常指针，但在code时将其视为一个别名即可
引用的本质：是常指针，类似于int const * p， but此处的*p是一个右值，不可修改

可以修改指针所指向的地址的值： *p = 1; 不可以让p ++，不改变指针指向
```

## 8、常量指针

```cpp
int * const p = nullptr;
p指针在常量区，指的内容可变, 指向不可变  

int a[10]
int &r = b;

栈					常量区

a[0]
.
.
a[9]		<-		  a
b					  r
```

## 9、引用作为函数的返回值

```cpp
直接传值，会有一个值拷贝动作，效率比较低

int & get() {
	int a = 10;
	// 返回的是栈中的变量，执行完会销毁
	return a;
	VScode中会直接不允许该操作
}

注：不要返回局部变量的引用

int & m = get(); // 返回的是局部变量a的引用，在这句话执行完成后会被OS自动回收，会出错
建议：int m = get(); // 应该使用值传递，将a的别名的地址传出
cout << m;

将a前面用static修饰即可传出，因为那样开辟的是全局变量，在程序执行完才收回内存，另外也可以由程序员自己在堆区开辟变量。

此外，如果函数返回的是引用的话，可以将这个函数当左值，C中都是右值。
    getA() = 10;
    cout << getA() << endl;
    
函数返回可以当左值，因为返回的是其本身，返回局部变量的引用不可以当左值
```

## 10、指针引用

```cpp
简化多级指针操作

struct teacher
{
    int id;
    char name[64];
};
// 指针的引用
int get(struct teacher *&t) {
	struct teacher * p = (struct teacher *) (sizeof(struct teacher));
	// 判空后再操作
}

void free(struct teacher *&t)
{
    if (t != nullptr)
    {
        free(t);
        return;
    }
}

struct teacher* p = nullptr;
free(p);
```

## 11、const修饰引用

```cpp
const 一般作用于函数形参上，用于保护形参，保护传入参数不被修改

const int a = 10; // 如果想对一个常量进行引用，必须是一个const引用
// int &b 被const修饰，不可修改b的值
const int &b = a;
cout << a << ' ' << b << endl;

int c = 20;
const int &d = c;              // 可以把一个普通变量，用一个const引用去接受，提高其安全性
cout << c << ' ' << d << endl; // 无法修改const引用的值，只能直接去修改int变量的值
c = 30;
cout << c << ' ' << d << endl;

// 这个print函数可以保证在函数内部，re不会被修改，but main中仍可修改
void printRe(const int &re)
{
    cout << "re = " << re << endl;
}

```

## 12、判断const所修饰对象

```cpp
const int  修饰int
int const  修饰int
const int * const :指针本身、指向的内容也不可改变
const int * 修饰int，表示指针指向的内容不可变
int * const ：指针本身不可改变，常量指针

const 修饰，先看左边，左边没有对象，再看右边

顶层const：对象本身是一个const，eg：const int *，对象本身是一个指针，但此处的const作用于int，所以是底层const
int* const：const作用于指针上，而该变量本身就是一个指针，所以是顶层const

eg：顶层const，在传参时'const'会被忽略，进而提示重定义
void f(const int a)
{
}

void f(int a)
{
}
```

```
注意： 对一个常量的引用，不能直接用 int & 去修饰，因为这样的话该常量就可以被改变了，所以需要用const修饰
const int & a = 40;
对常量加引用需要加const，不能直接用，加const的话，a就是常量40所分配的临时空间变量的别名

```

